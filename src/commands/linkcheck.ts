import { Telegraf, Context } from 'telegraf'
const needle = require('needle')

async function checkABUSEIP(ip) {
  //TODO: check if ipv6, should escape
  let options = { headers: { 'Key': process.env.ABUSEIPKEY, 'Accept': 'application/json' }, follow_max: 5 }
  let result = await needle('get', `https://api.abuseipdb.com/api/v2/check?ipAddress=${ip}`, options)
  try {
    if (result.body['data'] != undefined) {
      console.log(result.body)
      let reports = Number((result.body['data'])['abuseConfidenceScore'])
      result = reports > 0 ? { '<b>ABUSEIP</b>': '<code>malicious</code>' } : {}
    }
    else {
      result = {}
    }
  }
  catch (err) {
    console.log(err)
    result = {}
  }

  return result
}
async function checkOTX(ip) {
  let options = { headers: { 'X-OTX-API-KEY': process.env.OTXKEY }, follow_max: 5 }
  //TODO: check if ipv6
  let request_result = await needle('get', `https://otx.alienvault.com/api/v1/indicators/IPv4/${ip}/malware`, options)
  let result = {}
  try {
    let reports = Number((request_result.body['size']))
    if (reports > 0) {
      (request_result.body['data']).forEach(res => {
        let detections = res.detections
        let keys = Object.keys(detections)
        keys.forEach(element => {
          if (detections[element] != null)
            result[`<b>OTX ${element}</b>`] = `<code>${detections[element]}</code>`
        });
      });

    }
  }
  catch (err) {
    console.log(err)
    result = {}
  }

  return result
}

function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

async function virusTotalIDCheck(id, wait_ms) {
  //wait a bit for VT to process the request
  await sleep(wait_ms);
  let options = { headers: { 'x-apikey': process.env.VIRUSTOTALKEY, 'Accept': 'application/json' }, follow_max: 5 }
  return await needle('get', `https://www.virustotal.com/api/v3/analyses/${id}`, options)
}

async function checkVirusTotal(url) {
  // TODO: add support for community score
  // TODO: add limits: if more than 4 req per minute, add them to global list, wait a minute, send bulk 4 requests
  // TODO: add suport for bulk reading
  // TODO: add limit for 500 requests per day
  let options = { headers: { 'x-apikey': process.env.VIRUSTOTALKEY, 'Accept': 'application/json' }, follow_max: 5 }
  let data = { 'url': url }

  let result = await needle('post', `https://www.virustotal.com/api/v3/urls`, data, options)
  // console.log(result.body)
  if ('error' in result.body) {
    console.log(`VirusTotal: ${(result.body['error'])['message']}`)
    result = {}
  } else {
    let id = (result.body['data'])['id']

    result = await virusTotalIDCheck(id, 2000)
    while (result.body.data.attributes.status !== 'completed') {
      result = await virusTotalIDCheck(id, 3000)
    }

    let results = ((result.body['data'])['attributes'])['results']
    result = {}
    for (const [_, value] of Object.entries(results)) {
      if (value['category'] != 'harmless' && value['category'] != 'undetected') {
        result[`<b>${value['engine_name']}</b>`] = `<code>${value['result']}</code>`
      }
    }
  }
  return result
}

export function checkLinks(bot: Telegraf<Context>) {
  var dns = require('dns');

  bot.on('text', async ctx => {
    if (ctx.message.text !== undefined) {
      const REPLACE_REGEX = /^(https?):\/\//i
      const entities =
        ctx.message.entities || []
      let detected_urls = []
      for (const entity of entities) {
        if (entity.type === 'text_link' || entity.type === 'url') {
          if ('url' in entity) {
            detected_urls.push(entity.url)
          }
          else {
            detected_urls.push((ctx.message.text).substr(
              entity.offset,
              entity.length
            ))
          }
        }
      }

      if (detected_urls.length > 0) {
        detected_urls = [...new Set(detected_urls)];
        detected_urls.forEach(url => {
          url = url.replace(REPLACE_REGEX, '');
          url = url.split('/')[0]
          console.log(url)
          dns.lookup(url, async function (err, address, _) {
            if (err == null) {
              let ABUSEIP_result = await checkABUSEIP(address)
              let OTX_result = await checkOTX(address)
              let VT_result = await checkVirusTotal(url)

              let final_result = 'Possible threat: '
              if (ABUSEIP_result != {}) {
                for (const [key, value] of Object.entries(ABUSEIP_result)) {
                  final_result += `\n${key}: ${value}`
                }
              }
              if (OTX_result != {}) {
                for (const [key, value] of Object.entries(OTX_result)) {
                  final_result += `\n${key}: ${value}`
                }
              }
              if (VT_result != {}) {
                for (const [key, value] of Object.entries(VT_result)) {
                  final_result += `\n${key}: ${value}`
                }
              }

              if (final_result != 'Possible threat: ') {
                ctx.reply(final_result, { reply_to_message_id: ctx.message.message_id, parse_mode: 'HTML' });
              }
            }
            else {
              console.log(err)
            }
          });
        })
      }
    }
  })
}
